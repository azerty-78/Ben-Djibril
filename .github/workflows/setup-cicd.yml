name: üöÄ Frontend CI/CD

# ==========================================
# D√âCLENCHEMENT
# ==========================================
# Ce workflow se d√©clenche :
# - Automatiquement sur push vers main ou master
# - Automatiquement sur pull_request vers main ou master
# - Manuellement depuis l'onglet Actions (workflow_dispatch)
on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:  # Permet de d√©clencher manuellement depuis GitHub

# ==========================================
# VARIABLES GLOBALES
# ==========================================
env:
  DOCKER_IMAGE: azerty78/ben-djibril-site
  DOCKERFILE_PATH: setup-front/Dockerfile
  DOCKER_CONTEXT: .

# ==========================================
# JOBS
# ==========================================
jobs:
  # ==========================================
  # JOB 1: Create Git Tags
  # ==========================================
  tags:
    name: üè∑Ô∏è Create Git Tags
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üìã Tag Info
        run: |
          echo "‚úÖ Informations sur les tags Git"
          echo "Ref: ${{ github.ref }}"
          echo "SHA: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          
          # Afficher les tags existants
          git tag -l | head -10 || echo "Aucun tag trouv√©"
          
          # Si c'est un push sur main ou master, afficher les informations
          if [ "${{ github.ref }}" == "refs/heads/master" ] || [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "üìå Push sur ${{ github.ref_name }} d√©tect√©"
            echo "Commit: ${{ github.sha }}"
            echo "Message: $(git log -1 --pretty=%B)"
          fi
  
  # ==========================================
  # JOB 2: Build Docker Image
  # ==========================================
  build:
    needs: tags
    name: üî® Build & Push Docker Image
    runs-on: ubuntu-latest
    
    steps:
      # √âtape 1: Checkout du code
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      # √âtape 2: Nettoyer et recr√©er les contextes Docker correctement
      - name: üßπ Setup Docker Properly
        run: |
          # Supprimer seulement les contextes corrompus (pas buildx car BuildKit en a besoin)
          rm -rf ~/.docker/contexts 2>/dev/null || true
          
          # Recr√©er la structure de contextes correctement
          mkdir -p ~/.docker/contexts/meta
          
          # Cr√©er le r√©pertoire pour le contexte "." (hash de l'erreur)
          CONTEXT_DIR=~/.docker/contexts/meta/cdb4ee2aea69cc6a83331bbe96dc2caa9a299d21329efb0336fc02a82e1839a8
          mkdir -p "$CONTEXT_DIR"
          
          # Cr√©er le fichier meta.json pour le contexte "."
          cat > "$CONTEXT_DIR/meta.json" <<'EOF'
          {
            "Name": ".",
            "Metadata": {
              "Description": "Default context"
            },
            "Endpoints": {
              "docker": {
                "Host": "unix:///var/run/docker.sock",
                "SkipTLSVerify": false
              }
            }
          }
          EOF
          
          # V√©rifier que le fichier a √©t√© cr√©√©
          if [ -f "$CONTEXT_DIR/meta.json" ]; then
            echo "‚úÖ Contexte Docker '.' cr√©√© avec succ√®s"
          else
            echo "‚ùå Erreur: Impossible de cr√©er le contexte"
            exit 1
          fi
      
      # √âtape 3: Login √† DockerHub (TOUJOURS n√©cessaire pour pull les images de base)
      - name: üîê Login to DockerHub
        run: |
          # Utiliser docker login directement (le contexte "." existe maintenant)
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          
          # V√©rifier le login en testant un pull d'image publique
          echo "‚úÖ Login DockerHub r√©ussi"
          
          # Test: essayer de pull node:22.13.1-alpine pour v√©rifier l'authentification
          echo "Test: Pull de node:22.13.1-alpine..."
          docker pull node:22.13.1-alpine || {
            echo "‚ùå Erreur: Impossible de pull node:22.13.1-alpine"
            echo "V√©rification du config.json..."
            cat ~/.docker/config.json || echo "‚ö†Ô∏è Pas de config.json"
            exit 1
          }
          echo "‚úÖ Pull de node:22.13.1-alpine r√©ussi"
      
      # √âtape 4: Extract metadata (tags, labels)
      - name: üìã Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      # √âtape 5: Lire les variables depuis le fichier .env
      - name: üìÑ Read .env file
        id: env_vars
        run: |
          # V√©rifier que le fichier .env existe
          if [ ! -f "setup-front/.env" ]; then
            echo "‚ùå Erreur: Le fichier setup-front/.env n'existe pas"
            echo "üí° Assurez-vous que le fichier setup-front/.env est pr√©sent dans le repository"
            exit 1
          fi
          
          echo "‚úÖ Fichier setup-front/.env trouv√©"
          
          # Extraire les variables EmailJS depuis le fichier .env
          # Utiliser grep pour trouver les lignes et cut pour extraire les valeurs (apr√®s le =)
          # Supprimer les guillemets et espaces
          VITE_EMAILJS_PUBLIC_KEY=$(grep "^VITE_EMAILJS_PUBLIC_KEY=" setup-front/.env | cut -d '=' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//" || echo "")
          VITE_EMAILJS_SERVICE_ID=$(grep "^VITE_EMAILJS_SERVICE_ID=" setup-front/.env | cut -d '=' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//" || echo "")
          VITE_EMAILJS_CONTACT_TEMPLATE_ID=$(grep "^VITE_EMAILJS_CONTACT_TEMPLATE_ID=" setup-front/.env | cut -d '=' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//" || echo "")
          VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=$(grep "^VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=" setup-front/.env | cut -d '=' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed "s/^['\"]//;s/['\"]$//" || echo "")
          
          # V√©rifier que les variables ne sont pas vides
          MISSING_VARS=0
          if [ -z "$VITE_EMAILJS_PUBLIC_KEY" ]; then
            echo "‚ùå VITE_EMAILJS_PUBLIC_KEY est vide ou manquant"
            MISSING_VARS=1
          else
            echo "‚úÖ VITE_EMAILJS_PUBLIC_KEY: ${VITE_EMAILJS_PUBLIC_KEY:0:10}... (masqu√©)"
          fi
          
          if [ -z "$VITE_EMAILJS_SERVICE_ID" ]; then
            echo "‚ùå VITE_EMAILJS_SERVICE_ID est vide ou manquant"
            MISSING_VARS=1
          else
            echo "‚úÖ VITE_EMAILJS_SERVICE_ID: ${VITE_EMAILJS_SERVICE_ID:0:10}... (masqu√©)"
          fi
          
          if [ -z "$VITE_EMAILJS_CONTACT_TEMPLATE_ID" ]; then
            echo "‚ùå VITE_EMAILJS_CONTACT_TEMPLATE_ID est vide ou manquant"
            MISSING_VARS=1
          else
            echo "‚úÖ VITE_EMAILJS_CONTACT_TEMPLATE_ID: ${VITE_EMAILJS_CONTACT_TEMPLATE_ID:0:10}... (masqu√©)"
          fi
          
          if [ -z "$VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID" ]; then
            echo "‚ùå VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID est vide ou manquant"
            MISSING_VARS=1
          else
            echo "‚úÖ VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID: ${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID:0:10}... (masqu√©)"
          fi
          
          if [ "$MISSING_VARS" -eq 1 ]; then
            echo "‚ùå Erreur: Certaines variables EmailJS sont manquantes dans setup-front/.env"
            echo "üí° V√©rifiez que toutes les variables EmailJS sont d√©finies dans le fichier .env"
            exit 1
          fi
          
          echo "‚úÖ Toutes les variables EmailJS ont √©t√© extraites avec succ√®s du fichier .env"
          
          # Sauvegarder dans des variables d'environnement pour les √©tapes suivantes
          echo "VITE_EMAILJS_PUBLIC_KEY=$VITE_EMAILJS_PUBLIC_KEY" >> $GITHUB_ENV
          echo "VITE_EMAILJS_SERVICE_ID=$VITE_EMAILJS_SERVICE_ID" >> $GITHUB_ENV
          echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=$VITE_EMAILJS_CONTACT_TEMPLATE_ID" >> $GITHUB_ENV
          echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=$VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID" >> $GITHUB_ENV
      
      # √âtape 6: Build Docker Image (le contexte "." existe maintenant)
      - name: üî® Build Docker Image
        run: |
          # Supprimer compl√®tement buildx pour √©viter les conflits
          # Docker buildx le recr√©era automatiquement
          echo "üßπ Nettoyage de buildx avant le build..."
          rm -rf ~/.docker/buildx 2>/dev/null || true
          
          # Cr√©er un builder buildx par d√©faut si n√©cessaire
          echo "üîß Initialisation de buildx..."
          docker buildx create --name builder --use 2>/dev/null || docker buildx use builder 2>/dev/null || echo "‚ö†Ô∏è  Builder buildx d√©j√† existant ou cr√©ation √©chou√©e"
          docker buildx inspect --bootstrap >/dev/null 2>&1 || echo "‚ö†Ô∏è  Bootstrap buildx (peut √™tre normal)"
          
          # Le login a d√©j√† √©t√© v√©rifi√© dans l'√©tape pr√©c√©dente
          echo "‚úÖ Pr√™t pour le build Docker (login v√©rifi√© dans l'√©tape pr√©c√©dente)"
          
          # Pr√©parer les tags
          TAGS="${{ steps.meta.outputs.tags }}"
          if [ -z "$TAGS" ]; then
            # Fallback si metadata-action ne fonctionne pas
            TAGS="${{ env.DOCKER_IMAGE }}:latest ${{ env.DOCKER_IMAGE }}:${{ github.sha }}"
          fi
          
          # Construire les arguments --tag
          TAG_ARGS=""
          for tag in $TAGS; do
            TAG_ARGS="$TAG_ARGS --tag $tag"
          done
          
          # Construire l'image avec buildx directement (plus fiable que docker build avec DOCKER_BUILDKIT)
          # Utiliser --pull pour forcer le pull des images de base avec authentification
          # Les variables EmailJS sont maintenant dans l'environnement depuis l'√©tape pr√©c√©dente
          
          # D√©terminer les options de push
          if [ "${{ github.event_name }}" != "pull_request" ]; then
            # Push directement avec buildx (plus efficace)
            echo "üöÄ Build et push de l'image..."
            docker buildx build \
              --push \
              --pull \
              --file ${{ env.DOCKERFILE_PATH }} \
              $TAG_ARGS \
              --build-arg VITE_EMAILJS_PUBLIC_KEY="${VITE_EMAILJS_PUBLIC_KEY}" \
              --build-arg VITE_EMAILJS_SERVICE_ID="${VITE_EMAILJS_SERVICE_ID}" \
              --build-arg VITE_EMAILJS_CONTACT_TEMPLATE_ID="${VITE_EMAILJS_CONTACT_TEMPLATE_ID}" \
              --build-arg VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID="${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID}" \
              ${{ env.DOCKER_CONTEXT }}
            
            # V√©rifier que l'image a bien √©t√© push√©e sur Docker Hub
            echo "üîç V√©rification que l'image est bien disponible sur Docker Hub..."
            PUSH_SUCCESS=0
            for tag in $TAGS; do
              echo "V√©rification du tag: $tag"
              # Attendre un peu pour que le push soit propag√©
              sleep 2
              # V√©rifier avec docker manifest inspect (n√©cessite d'√™tre authentifi√©)
              if docker manifest inspect "$tag" >/dev/null 2>&1; then
                echo "‚úÖ Tag $tag confirm√© sur Docker Hub"
                PUSH_SUCCESS=1
              else
                echo "‚ö†Ô∏è  Tag $tag non v√©rifi√© (peut √™tre normal si propagation en cours)"
              fi
            done
            
            if [ "$PUSH_SUCCESS" -eq 1 ]; then
              echo "‚úÖ Au moins un tag confirm√© sur Docker Hub - Push r√©ussi!"
            else
              echo "‚ö†Ô∏è  Aucun tag v√©rifi√©, mais le push semble avoir r√©ussi (propagation peut prendre quelques secondes)"
            fi
          else
            # Pour les PR, seulement build (pas de push)
            echo "üî® Build de l'image (PR - pas de push)..."
            docker buildx build \
              --load \
              --pull \
              --file ${{ env.DOCKERFILE_PATH }} \
              $TAG_ARGS \
              --build-arg VITE_EMAILJS_PUBLIC_KEY="${VITE_EMAILJS_PUBLIC_KEY}" \
              --build-arg VITE_EMAILJS_SERVICE_ID="${VITE_EMAILJS_SERVICE_ID}" \
              --build-arg VITE_EMAILJS_CONTACT_TEMPLATE_ID="${VITE_EMAILJS_CONTACT_TEMPLATE_ID}" \
              --build-arg VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID="${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID}" \
              ${{ env.DOCKER_CONTEXT }}
          fi
      
      # √âtape 7: Afficher les informations de l'image
      - name: üìä Image Info
        if: success()
        run: |
          echo "‚úÖ Image build√©e avec succ√®s!"
          echo "üì¶ Image: ${{ env.DOCKER_IMAGE }}"
          echo "üè∑Ô∏è  Tags: ${{ steps.meta.outputs.tags }}"
          echo ""
          echo "üìã Images Docker disponibles:"
          docker images | grep "${{ env.DOCKER_IMAGE }}" || echo "‚ö†Ô∏è  Aucune image locale trouv√©e (normal si --push a √©t√© utilis√©)"
  
  # ==========================================
  # JOB 3: Test Docker Image (optionnel pour l'instant)
  # ==========================================
  test:
    name: üß™ Test Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name != 'pull_request'  # Skip tests sur PR
    
    steps:
      # √âtape 1: Checkout
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      # √âtape 2: Login √† DockerHub
      - name: üîê Login to DockerHub
        run: |
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          echo "‚úÖ Login DockerHub r√©ussi"
      
      # √âtape 3: Pull l'image build√©e depuis Docker Hub
      - name: üê≥ Pull Docker Image
        run: |
          echo "üì• Pull de l'image Docker depuis Docker Hub..."
          
          # Liste des tags √† essayer (par ordre de priorit√©)
          TAGS_TO_TRY=(
            "${{ env.DOCKER_IMAGE }}:latest"
            "${{ env.DOCKER_IMAGE }}:${{ github.ref_name }}"
            "${{ env.DOCKER_IMAGE }}:${{ github.sha }}"
            "${{ env.DOCKER_IMAGE }}:${{ github.ref_name }}-${{ github.sha }}"
          )
          
          PULL_SUCCESS=0
          PULLED_TAG=""
          
          for tag in "${TAGS_TO_TRY[@]}"; do
            echo "Tentative de pull: $tag"
            if docker pull "$tag" 2>/dev/null; then
              echo "‚úÖ Image pull√©e avec succ√®s: $tag"
              PULL_SUCCESS=1
              PULLED_TAG="$tag"
              break
            else
              echo "‚ö†Ô∏è  Tag $tag non disponible, essai suivant..."
            fi
          done
          
          if [ "$PULL_SUCCESS" -eq 0 ]; then
            echo "‚ùå Erreur: Impossible de pull l'image avec aucun des tags essay√©s"
            echo "Tags essay√©s: ${TAGS_TO_TRY[*]}"
            exit 1
          fi
          
          # V√©rifier que l'image est bien pr√©sente localement
          if docker images | grep -q "${{ env.DOCKER_IMAGE }}"; then
            echo "‚úÖ Image confirm√©e localement:"
            docker images | grep "${{ env.DOCKER_IMAGE }}"
          else
            echo "‚ùå Erreur: Image non trouv√©e localement apr√®s le pull"
            exit 1
          fi
          
          # Exporter le tag pull√© pour les √©tapes suivantes
          echo "PULLED_TAG=$PULLED_TAG" >> $GITHUB_ENV
      
      # √âtape 4: Test basique (v√©rifier que le conteneur d√©marre)
      - name: ‚úÖ Test Container Start
        run: |
          # Utiliser le tag qui a √©t√© pull√© avec succ√®s
          TEST_TAG="${PULLED_TAG:-${{ env.DOCKER_IMAGE }}:latest}"
          echo "üß™ Test du conteneur avec le tag: $TEST_TAG"
          
          # D√©marrer le conteneur
          if docker run -d --name test-container -p 8080:80 "$TEST_TAG"; then
            echo "‚úÖ Conteneur d√©marr√© avec succ√®s"
          else
            echo "‚ùå Erreur: Impossible de d√©marrer le conteneur"
            exit 1
          fi
          
          # Attendre que le conteneur soit pr√™t
          echo "‚è≥ Attente que le conteneur soit pr√™t..."
          sleep 5
          
          # V√©rifier que le conteneur est en cours d'ex√©cution
          if ! docker ps | grep -q test-container; then
            echo "‚ùå Erreur: Le conteneur n'est pas en cours d'ex√©cution"
            docker logs test-container
            docker rm -f test-container
            exit 1
          fi
          
          # Tester l'endpoint
          echo "üîç Test de l'endpoint HTTP..."
          if curl -f http://localhost:8080/health >/dev/null 2>&1 || curl -f http://localhost:8080 >/dev/null 2>&1; then
            echo "‚úÖ Endpoint HTTP accessible - Conteneur fonctionnel!"
          else
            echo "‚ö†Ô∏è  Endpoint HTTP non accessible, mais conteneur en cours d'ex√©cution"
            docker logs test-container
          fi
          
          # Nettoyage
          echo "üßπ Nettoyage du conteneur de test..."
          docker stop test-container || true
          docker rm test-container || true
          echo "‚úÖ Test termin√© avec succ√®s!"
