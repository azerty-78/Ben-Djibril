name: üöÄ Frontend CI/CD

# ==========================================
# D√âCLENCHEMENT
# ==========================================
# Ce workflow se d√©clenche :
# - Automatiquement sur push vers main ou master
# - Automatiquement sur pull_request vers main ou master
# - Manuellement depuis l'onglet Actions (workflow_dispatch)
on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch: # Permet de d√©clencher manuellement depuis GitHub

# ==========================================
# PERMISSIONS
# ==========================================
permissions:
  contents: write # N√©cessaire pour cr√©er des releases et pousser des tags
  packages: write # N√©cessaire pour pousser des images Docker (si utilis√©)

# ==========================================
# VARIABLES GLOBALES
# ==========================================
env:
  DOCKER_IMAGE: azerty78/ben-djibril-site
  DOCKERFILE_PATH: setup-front/Dockerfile
  DOCKER_CONTEXT: .

# ==========================================
# JOBS
# ==========================================
jobs:
  # ==========================================
  # JOB 1: Create Git Tags
  # ==========================================
  tags:
    name: üè∑Ô∏è Create Git Tags
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag_created: ${{ steps.tag.outputs.created }}
      tag_name: ${{ steps.tag.outputs.name }}
      tag_type: ${{ steps.tag.outputs.type }}
      is_release: ${{ steps.tag.outputs.is_release }}
      semantic_version: ${{ steps.tag.outputs.semantic_version }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ‚öôÔ∏è Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: üìã Extract Version & Info
        id: version
        run: |
          echo "‚úÖ Informations sur les tags Git"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìå Ref: ${{ github.ref }}"
          echo "üîñ SHA: ${{ github.sha }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üë§ Auteur: $(git log -1 --pretty=%an)"
          echo "üìÖ Date: $(git log -1 --pretty=%cd --date=format:%Y-%m-%d\ %H:%M:%S)"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          # Lire la version depuis package.json (m√©thode bash pure)
          if [ -f "package.json" ]; then
            # Extraire la version avec grep et sed (m√©thode simple et fiable)
            PACKAGE_VERSION=$(grep -m 1 '"version"' package.json | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
            if [ -z "$PACKAGE_VERSION" ]; then
              PACKAGE_VERSION="0.0.0"
            fi
            echo "üì¶ Version package.json: $PACKAGE_VERSION"
            echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è package.json non trouv√©, utilisation de la version par d√©faut"
            echo "version=0.0.0" >> $GITHUB_OUTPUT
          fi

          # Afficher les 10 derniers tags
          echo ""
          echo "üìã Tags existants (10 derniers):"
          git tag -l --sort=-version:refname | head -10 || echo "  Aucun tag trouv√©"

          # Afficher les informations du commit
          echo ""
          echo "üìù Dernier commit:"
          echo "  SHA: $(git log -1 --pretty=%H)"
          COMMIT_MSG_FIRST_LINE=$(git log -1 --pretty=%B | head -n 1)
          echo "  Message: $COMMIT_MSG_FIRST_LINE"
          echo "  Auteur: $(git log -1 --pretty='%an <%ae>')"

      - name: üìä Analyze Changes
        id: changes
        run: |
          echo "üìä Analyse des changements:"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          # Compter les fichiers modifi√©s
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            FILES_CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | wc -l)
            echo "üìÅ Fichiers modifi√©s: $FILES_CHANGED"
            
            # Afficher les types de changements
            echo ""
            echo "üìù Types de changements:"
            git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | \
              awk '{print "  " $1 " " $2}' | head -20 || echo "  Aucun changement d√©tect√©"
          else
            # Pour les pushes, comparer avec le commit pr√©c√©dent
            PREV_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "")
            if [ -n "$PREV_SHA" ]; then
              FILES_CHANGED=$(git diff --name-only $PREV_SHA ${{ github.sha }} | wc -l)
              echo "üìÅ Fichiers modifi√©s: $FILES_CHANGED"
              
              echo ""
              echo "üìù Types de changements:"
              git diff --name-status $PREV_SHA ${{ github.sha }} | \
                awk '{print "  " $1 " " $2}' | head -20 || echo "  Aucun changement d√©tect√©"
            else
              echo "‚ÑπÔ∏è Premier commit de la branche"
            fi
          fi

          # D√©tecter le type de changement (feat, fix, etc.)
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -qiE "^(feat|feature)"; then
            CHANGE_TYPE="‚ú® Feature"
          elif echo "$COMMIT_MSG" | grep -qiE "^(fix|bugfix)"; then
            CHANGE_TYPE="üêõ Fix"
          elif echo "$COMMIT_MSG" | grep -qiE "^(refactor)"; then
            CHANGE_TYPE="‚ôªÔ∏è Refactor"
          elif echo "$COMMIT_MSG" | grep -qiE "^(docs|documentation)"; then
            CHANGE_TYPE="üìö Documentation"
          elif echo "$COMMIT_MSG" | grep -qiE "^(test)"; then
            CHANGE_TYPE="üß™ Test"
          elif echo "$COMMIT_MSG" | grep -qiE "^(chore)"; then
            CHANGE_TYPE="üîß Chore"
          else
            CHANGE_TYPE="üìù Update"
          fi

          echo ""
          echo "üè∑Ô∏è Type de changement d√©tect√©: $CHANGE_TYPE"
          echo "change_type=$CHANGE_TYPE" >> $GITHUB_OUTPUT

      - name: üè∑Ô∏è Create Git Tag
        id: tag
        if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SHA="${{ github.sha }}"
          BRANCH="${{ github.ref_name }}"
          COMMIT_MSG=$(git log -1 --pretty=%B)
          AUTHOR=$(git log -1 --pretty=%an)
          DATE=$(git log -1 --pretty=%cd --date=format:%Y-%m-%d\ %H:%M:%S)
          SHORT_SHA=$(echo $SHA | cut -c1-7)

          # D√©tecter le type de changement pour d√©terminer le type de tag
          CHANGE_TYPE="${{ steps.changes.outputs.change_type }}"

          # Si la version est 0.0.0, cr√©er un tag de d√©veloppement
          # Sinon, cr√©er un tag s√©mantique (v1.0.0, v1.1.0, etc.)
          if [ "$VERSION" = "0.0.0" ]; then
            # Tag de d√©veloppement avec SHA et timestamp
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            TAG_NAME="dev-${SHORT_SHA}-${TIMESTAMP}"
            TAG_TYPE="development"
            echo "üîß Cr√©ation d'un tag de d√©veloppement: $TAG_NAME"
          else
            # Tag s√©mantique bas√© sur la version (v1.0.0, v1.1.0, etc.)
            TAG_NAME="v${VERSION}"
            TAG_TYPE="semantic"
            
            # V√©rifier si le tag s√©mantique existe d√©j√†
            if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Le tag s√©mantique $TAG_NAME existe d√©j√†"
              echo "‚ÑπÔ∏è Utilisation d'un tag de d√©veloppement √† la place"
              TIMESTAMP=$(date +%Y%m%d%H%M%S)
              TAG_NAME="dev-${SHORT_SHA}-${TIMESTAMP}"
              TAG_TYPE="development"
            else
              echo "üéâ Cr√©ation d'un tag s√©mantique: $TAG_NAME"
            fi
          fi

          # Cr√©er le message du tag enrichi (format simplifi√© pour √©viter les probl√®mes YAML)
          TAG_MESSAGE="Release $TAG_NAME - Version: $VERSION - Commit: $SHA - Branch: $BRANCH - Auteur: $AUTHOR - Date: $DATE - Type: $TAG_TYPE - Changement: $CHANGE_TYPE - Message: $COMMIT_MSG - G√©n√©r√© automatiquement par GitHub Actions"

          # Cr√©er le tag annot√©
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE" "$SHA"

          echo "‚úÖ Tag cr√©√©: $TAG_NAME"
          echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "created=true" >> $GITHUB_OUTPUT
          echo "type=$TAG_TYPE" >> $GITHUB_OUTPUT

          # D√©tecter si c'est une release s√©mantique (version != 0.0.0 et tag s√©mantique)
          if [ "$VERSION" != "0.0.0" ] && [ "$TAG_TYPE" = "semantic" ]; then
            echo "is_release=true" >> $GITHUB_OUTPUT
            echo "semantic_version=$VERSION" >> $GITHUB_OUTPUT
            echo "üéâ Release s√©mantique d√©tect√©e (version: $VERSION)"
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "semantic_version=" >> $GITHUB_OUTPUT
          fi

      - name: üöÄ Push Tags
        if: steps.tag.outputs.created == 'true'
        run: |
          TAG_NAME="${{ steps.tag.outputs.name }}"
          echo "üöÄ Push du tag $TAG_NAME vers le d√©p√¥t..."
          git push origin "$TAG_NAME" || {
            echo "‚ö†Ô∏è Erreur lors du push du tag, peut-√™tre qu'il existe d√©j√† sur le serveur"
            exit 0  # Ne pas faire √©chouer le workflow si le tag existe d√©j√†
          }
          echo "‚úÖ Tag $TAG_NAME pouss√© avec succ√®s"

      - name: üìã Summary
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìã R√âSUM√â DU JOB TAGS"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Version: ${{ steps.version.outputs.version }}"
          if [ "${{ steps.tag.outputs.created }}" == "true" ]; then
            echo "‚úÖ Tag cr√©√©: ${{ steps.tag.outputs.name }}"
            echo "üè∑Ô∏è  Type de tag: ${{ steps.tag.outputs.type }}"
            if [ "${{ steps.tag.outputs.is_release }}" == "true" ]; then
              echo "üéâ Release s√©mantique: ${{ steps.tag.outputs.semantic_version }}"
              echo "üì¶ L'image Docker sera tagg√©e avec: ${{ steps.tag.outputs.name }}"
              echo "üöÄ Une release GitHub sera cr√©√©e automatiquement"
            else
              echo "üîß Tag de d√©veloppement cr√©√©"
            fi
          else
            echo "‚ÑπÔ∏è Aucun tag cr√©√© (PR ou branche non principale)"
          fi
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  # ==========================================
  # JOB 2: Build Docker Image
  # ==========================================
  build:
    needs: tags
    name: üî® Build & Push Docker Image
    runs-on: ubuntu-latest

    steps:
      # √âtape 1: Checkout du code
      - name: üì• Checkout code
        uses: actions/checkout@v4

      # √âtape 2: Nettoyer et recr√©er les contextes Docker correctement
      - name: üßπ Setup Docker Properly
        run: |
          # Supprimer seulement les contextes corrompus (pas buildx car BuildKit en a besoin)
          rm -rf ~/.docker/contexts 2>/dev/null || true

          # Recr√©er la structure de contextes correctement
          mkdir -p ~/.docker/contexts/meta

          # Cr√©er le r√©pertoire pour le contexte "." (hash de l'erreur)
          CONTEXT_DIR=~/.docker/contexts/meta/cdb4ee2aea69cc6a83331bbe96dc2caa9a299d21329efb0336fc02a82e1839a8
          mkdir -p "$CONTEXT_DIR"

          # Cr√©er le fichier meta.json pour le contexte "."
          cat > "$CONTEXT_DIR/meta.json" <<'EOF'
          {
            "Name": ".",
            "Metadata": {
              "Description": "Default context"
            },
            "Endpoints": {
              "docker": {
                "Host": "unix:///var/run/docker.sock",
                "SkipTLSVerify": false
              }
            }
          }
          EOF

          # V√©rifier que le fichier a √©t√© cr√©√©
          if [ -f "$CONTEXT_DIR/meta.json" ]; then
            echo "‚úÖ Contexte Docker '.' cr√©√© avec succ√®s"
          else
            echo "‚ùå Erreur: Impossible de cr√©er le contexte"
            exit 1
          fi

      # √âtape 3: Login √† DockerHub (TOUJOURS n√©cessaire pour pull les images de base)
      - name: üîê Login to DockerHub
        run: |
          # Utiliser docker login directement (le contexte "." existe maintenant)
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

          # V√©rifier le login en testant un pull d'image publique
          echo "‚úÖ Login DockerHub r√©ussi"

          # Test: essayer de pull node:22.13.1-alpine pour v√©rifier l'authentification
          echo "Test: Pull de node:22.13.1-alpine..."
          docker pull node:22.13.1-alpine || {
            echo "‚ùå Erreur: Impossible de pull node:22.13.1-alpine"
            echo "V√©rification du config.json..."
            cat ~/.docker/config.json || echo "‚ö†Ô∏è Pas de config.json"
            exit 1
          }
          echo "‚úÖ Pull de node:22.13.1-alpine r√©ussi"

      # √âtape 4: Extract metadata (tags, labels) avec int√©gration des tags Git
      - name: üìã Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            # Tags Git (prioritaires si disponibles)
            type=raw,value=${{ needs.tags.outputs.tag_name }},enable=${{ needs.tags.outputs.tag_created == 'true' }}
            # Tags s√©mantiques bas√©s sur la version
            type=semver,pattern={{version}},enable=${{ needs.tags.outputs.is_release == 'true' }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ needs.tags.outputs.is_release == 'true' }}
            # Tags de branche et SHA (fallback)
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            # Tag latest uniquement sur la branche principale
            type=raw,value=latest,enable={{is_default_branch}}
            # Tags pour les PRs
            type=ref,event=pr

      # √âtape 5: Lire les variables depuis le fichier .env
      - name: üìÑ Load environment variables
        id: env
        run: |
          # Fonction pour extraire une variable d'un fichier .env
          extract_env_var() {
            local var_name=$1
            local file_path=$2
            if [ -f "$file_path" ]; then
              # Extraire la variable (ignorer les commentaires, g√©rer les espaces, guillemets, etc.)
              grep -E "^${var_name}=" "$file_path" | sed -E "s/^${var_name}=['\"]?([^'\"]*)['\"]?$/\1/" | head -1 | xargs || echo ""
            else
              echo ""
            fi
          }

          # Lire les variables depuis setup-front/.env si le fichier existe
          if [ -f "setup-front/.env" ]; then
            echo "‚úÖ Fichier .env trouv√©, lecture des variables..."
            
            # Extraire les variables EmailJS
            VITE_EMAILJS_PUBLIC_KEY=$(extract_env_var "VITE_EMAILJS_PUBLIC_KEY" "setup-front/.env")
            VITE_EMAILJS_SERVICE_ID=$(extract_env_var "VITE_EMAILJS_SERVICE_ID" "setup-front/.env")
            VITE_EMAILJS_CONTACT_TEMPLATE_ID=$(extract_env_var "VITE_EMAILJS_CONTACT_TEMPLATE_ID" "setup-front/.env")
            VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=$(extract_env_var "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID" "setup-front/.env")
            
            # Afficher les variables (masquer les valeurs sensibles)
            if [ -n "$VITE_EMAILJS_PUBLIC_KEY" ]; then
              echo "VITE_EMAILJS_PUBLIC_KEY=${VITE_EMAILJS_PUBLIC_KEY:0:10}..."
            else
              echo "VITE_EMAILJS_PUBLIC_KEY=(vide)"
            fi
            if [ -n "$VITE_EMAILJS_SERVICE_ID" ]; then
              echo "VITE_EMAILJS_SERVICE_ID=${VITE_EMAILJS_SERVICE_ID:0:10}..."
            else
              echo "VITE_EMAILJS_SERVICE_ID=(vide)"
            fi
            if [ -n "$VITE_EMAILJS_CONTACT_TEMPLATE_ID" ]; then
              echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=${VITE_EMAILJS_CONTACT_TEMPLATE_ID:0:10}..."
            else
              echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=(vide)"
            fi
            if [ -n "$VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID" ]; then
              echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID:0:10}..."
            else
              echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=(vide)"
            fi
            
            # V√©rifier que les variables ne sont pas vides
            MISSING_VARS=0
            if [ -z "$VITE_EMAILJS_PUBLIC_KEY" ]; then
              echo "‚ùå VITE_EMAILJS_PUBLIC_KEY est vide ou manquant"
              MISSING_VARS=1
            fi
            if [ -z "$VITE_EMAILJS_SERVICE_ID" ]; then
              echo "‚ùå VITE_EMAILJS_SERVICE_ID est vide ou manquant"
              MISSING_VARS=1
            fi
            if [ -z "$VITE_EMAILJS_CONTACT_TEMPLATE_ID" ]; then
              echo "‚ùå VITE_EMAILJS_CONTACT_TEMPLATE_ID est vide ou manquant"
              MISSING_VARS=1
            fi
            if [ -z "$VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID" ]; then
              echo "‚ùå VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID est vide ou manquant"
              MISSING_VARS=1
            fi
            
            if [ "$MISSING_VARS" -eq 1 ]; then
              echo "‚ùå Erreur: Certaines variables EmailJS sont manquantes dans setup-front/.env"
              echo "üí° V√©rifiez que toutes les variables EmailJS sont d√©finies dans le fichier .env"
              exit 1
            fi
            
            # Exporter pour les prochaines √©tapes
            echo "VITE_EMAILJS_PUBLIC_KEY=${VITE_EMAILJS_PUBLIC_KEY}" >> $GITHUB_ENV
            echo "VITE_EMAILJS_SERVICE_ID=${VITE_EMAILJS_SERVICE_ID}" >> $GITHUB_ENV
            echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=${VITE_EMAILJS_CONTACT_TEMPLATE_ID}" >> $GITHUB_ENV
            echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID}" >> $GITHUB_ENV
            echo "‚úÖ Toutes les variables EmailJS ont √©t√© extraites avec succ√®s"
          else
            echo "‚ö†Ô∏è Fichier setup-front/.env non trouv√©, utilisation de valeurs vides"
            echo "VITE_EMAILJS_PUBLIC_KEY=" >> $GITHUB_ENV
            echo "VITE_EMAILJS_SERVICE_ID=" >> $GITHUB_ENV
            echo "VITE_EMAILJS_CONTACT_TEMPLATE_ID=" >> $GITHUB_ENV
            echo "VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=" >> $GITHUB_ENV
          fi

      # √âtape 6: Build Docker Image (le contexte "." existe maintenant)
      - name: üî® Build Docker Image
        run: |
          # Supprimer compl√®tement buildx pour √©viter les conflits
          # Docker buildx le recr√©era automatiquement
          echo "üßπ Nettoyage de buildx avant le build..."
          rm -rf ~/.docker/buildx 2>/dev/null || true

          # Cr√©er un builder buildx par d√©faut si n√©cessaire
          echo "üîß Initialisation de buildx..."
          docker buildx create --name builder --use 2>/dev/null || docker buildx use builder 2>/dev/null || echo "‚ö†Ô∏è  Builder buildx d√©j√† existant ou cr√©ation √©chou√©e"
          docker buildx inspect --bootstrap >/dev/null 2>&1 || echo "‚ö†Ô∏è  Bootstrap buildx (peut √™tre normal)"

          # Le login a d√©j√† √©t√© v√©rifi√© dans l'√©tape pr√©c√©dente
          echo "‚úÖ Pr√™t pour le build Docker (login v√©rifi√© dans l'√©tape pr√©c√©dente)"

          # Pr√©parer les tags
          TAGS="${{ steps.meta.outputs.tags }}"
          if [ -z "$TAGS" ]; then
            # Fallback si metadata-action ne fonctionne pas
            TAGS="${{ env.DOCKER_IMAGE }}:latest ${{ env.DOCKER_IMAGE }}:${{ github.sha }}"
          fi

          # Construire les arguments --tag
          TAG_ARGS=""
          for tag in $TAGS; do
            TAG_ARGS="$TAG_ARGS --tag $tag"
          done

          # Construire l'image avec buildx directement (plus fiable que docker build avec DOCKER_BUILDKIT)
          # Utiliser --pull pour forcer le pull des images de base avec authentification
          # Les variables EmailJS sont maintenant dans l'environnement depuis l'√©tape pr√©c√©dente

          # D√©terminer les options de push
          if [ "${{ github.event_name }}" != "pull_request" ]; then
            # Push directement avec buildx (plus efficace)
            echo "üöÄ Build et push de l'image..."
            docker buildx build \
              --push \
              --pull \
              --file ${{ env.DOCKERFILE_PATH }} \
              $TAG_ARGS \
              --build-arg VITE_EMAILJS_PUBLIC_KEY="${VITE_EMAILJS_PUBLIC_KEY}" \
              --build-arg VITE_EMAILJS_SERVICE_ID="${VITE_EMAILJS_SERVICE_ID}" \
              --build-arg VITE_EMAILJS_CONTACT_TEMPLATE_ID="${VITE_EMAILJS_CONTACT_TEMPLATE_ID}" \
              --build-arg VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID="${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID}" \
              ${{ env.DOCKER_CONTEXT }}
            
            # V√©rifier que l'image a bien √©t√© push√©e sur Docker Hub
            echo "üîç V√©rification que l'image est bien disponible sur Docker Hub..."
            PUSH_SUCCESS=0
            for tag in $TAGS; do
              echo "V√©rification du tag: $tag"
              # Attendre un peu pour que le push soit propag√©
              sleep 2
              # V√©rifier avec docker manifest inspect (n√©cessite d'√™tre authentifi√©)
              if docker manifest inspect "$tag" >/dev/null 2>&1; then
                echo "‚úÖ Tag $tag confirm√© sur Docker Hub"
                PUSH_SUCCESS=1
              else
                echo "‚ö†Ô∏è  Tag $tag non v√©rifi√© (peut √™tre normal si propagation en cours)"
              fi
            done
            
            if [ "$PUSH_SUCCESS" -eq 1 ]; then
              echo "‚úÖ Au moins un tag confirm√© sur Docker Hub - Push r√©ussi!"
            else
              echo "‚ö†Ô∏è  Aucun tag v√©rifi√©, mais le push semble avoir r√©ussi (propagation peut prendre quelques secondes)"
            fi
          else
            # Pour les PR, seulement build (pas de push)
            echo "üî® Build de l'image (PR - pas de push)..."
            docker buildx build \
              --load \
              --pull \
              --file ${{ env.DOCKERFILE_PATH }} \
              $TAG_ARGS \
              --build-arg VITE_EMAILJS_PUBLIC_KEY="${VITE_EMAILJS_PUBLIC_KEY}" \
              --build-arg VITE_EMAILJS_SERVICE_ID="${VITE_EMAILJS_SERVICE_ID}" \
              --build-arg VITE_EMAILJS_CONTACT_TEMPLATE_ID="${VITE_EMAILJS_CONTACT_TEMPLATE_ID}" \
              --build-arg VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID="${VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID}" \
              ${{ env.DOCKER_CONTEXT }}
          fi

      # √âtape 7: Afficher les informations de l'image
      - name: üìä Image Info
        if: success()
        run: |
          echo "‚úÖ Image build√©e avec succ√®s!"
          echo "üì¶ Image: ${{ env.DOCKER_IMAGE }}"
          echo "üè∑Ô∏è  Tags: ${{ steps.meta.outputs.tags }}"
          echo ""
          echo "üìã Images Docker disponibles:"
          docker images | grep "${{ env.DOCKER_IMAGE }}" || echo "‚ö†Ô∏è  Aucune image locale trouv√©e (normal si --push a √©t√© utilis√©)"

  # ==========================================
  # JOB 3: Test Docker Image (optionnel pour l'instant)
  # ==========================================
  test:
    name: üß™ Test Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name != 'pull_request' # Skip tests sur PR

    steps:
      # √âtape 1: Checkout
      - name: üì• Checkout code
        uses: actions/checkout@v4

      # √âtape 2: Nettoyer et recr√©er les contextes Docker correctement
      - name: üßπ Setup Docker Properly
        run: |
          # Supprimer seulement les contextes corrompus
          rm -rf ~/.docker/contexts 2>/dev/null || true

          # Recr√©er la structure de contextes correctement
          mkdir -p ~/.docker/contexts/meta

          # Cr√©er le r√©pertoire pour le contexte "." (hash de l'erreur)
          CONTEXT_DIR=~/.docker/contexts/meta/cdb4ee2aea69cc6a83331bbe96dc2caa9a299d21329efb0336fc02a82e1839a8
          mkdir -p "$CONTEXT_DIR"

          # Cr√©er le fichier meta.json pour le contexte "."
          cat > "$CONTEXT_DIR/meta.json" <<'EOF'
          {
            "Name": ".",
            "Metadata": {
              "Description": "Default context"
            },
            "Endpoints": {
              "docker": {
                "Host": "unix:///var/run/docker.sock",
                "SkipTLSVerify": false
              }
            }
          }
          EOF

          # V√©rifier que le fichier a √©t√© cr√©√©
          if [ -f "$CONTEXT_DIR/meta.json" ]; then
            echo "‚úÖ Contexte Docker '.' cr√©√© avec succ√®s"
          else
            echo "‚ùå Erreur: Impossible de cr√©er le contexte"
            exit 1
          fi

      # √âtape 3: Login √† DockerHub
      - name: üîê Login to DockerHub
        run: |
          echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          echo "‚úÖ Login DockerHub r√©ussi"

      # √âtape 4: Pull l'image build√©e depuis Docker Hub
      - name: üê≥ Pull Docker Image
        run: |
          echo "üì• Pull de l'image Docker depuis Docker Hub..."

          # Liste des tags √† essayer (par ordre de priorit√©)
          TAGS_TO_TRY=(
            "${{ env.DOCKER_IMAGE }}:latest"
            "${{ env.DOCKER_IMAGE }}:${{ github.ref_name }}"
            "${{ env.DOCKER_IMAGE }}:${{ github.sha }}"
            "${{ env.DOCKER_IMAGE }}:${{ github.ref_name }}-${{ github.sha }}"
          )

          PULL_SUCCESS=0
          PULLED_TAG=""

          for tag in "${TAGS_TO_TRY[@]}"; do
            echo "Tentative de pull: $tag"
            if docker pull "$tag" 2>/dev/null; then
              echo "‚úÖ Image pull√©e avec succ√®s: $tag"
              PULL_SUCCESS=1
              PULLED_TAG="$tag"
              break
            else
              echo "‚ö†Ô∏è  Tag $tag non disponible, essai suivant..."
            fi
          done

          if [ "$PULL_SUCCESS" -eq 0 ]; then
            echo "‚ùå Erreur: Impossible de pull l'image avec aucun des tags essay√©s"
            echo "Tags essay√©s: ${TAGS_TO_TRY[*]}"
            exit 1
          fi

          # V√©rifier que l'image est bien pr√©sente localement
          if docker images | grep -q "${{ env.DOCKER_IMAGE }}"; then
            echo "‚úÖ Image confirm√©e localement:"
            docker images | grep "${{ env.DOCKER_IMAGE }}"
          else
            echo "‚ùå Erreur: Image non trouv√©e localement apr√®s le pull"
            exit 1
          fi

          # Exporter le tag pull√© pour les √©tapes suivantes
          echo "PULLED_TAG=$PULLED_TAG" >> $GITHUB_ENV

      # √âtape 5: Test basique (v√©rifier que le conteneur d√©marre)
      - name: ‚úÖ Test Container Start
        run: |
          # Utiliser le tag qui a √©t√© pull√© avec succ√®s
          TEST_TAG="${PULLED_TAG:-${{ env.DOCKER_IMAGE }}:latest}"
          echo "üß™ Test du conteneur avec le tag: $TEST_TAG"

          # D√©marrer le conteneur
          if docker run -d --name test-container -p 8080:80 "$TEST_TAG"; then
            echo "‚úÖ Conteneur d√©marr√© avec succ√®s"
          else
            echo "‚ùå Erreur: Impossible de d√©marrer le conteneur"
            exit 1
          fi

          # Attendre que le conteneur soit pr√™t
          echo "‚è≥ Attente que le conteneur soit pr√™t..."
          sleep 5

          # V√©rifier que le conteneur est en cours d'ex√©cution
          if ! docker ps | grep -q test-container; then
            echo "‚ùå Erreur: Le conteneur n'est pas en cours d'ex√©cution"
            docker logs test-container
            docker rm -f test-container
            exit 1
          fi

          # Tester l'endpoint
          echo "üîç Test de l'endpoint HTTP..."
          if curl -f http://localhost:8080/health >/dev/null 2>&1 || curl -f http://localhost:8080 >/dev/null 2>&1; then
            echo "‚úÖ Endpoint HTTP accessible - Conteneur fonctionnel!"
          else
            echo "‚ö†Ô∏è  Endpoint HTTP non accessible, mais conteneur en cours d'ex√©cution"
            docker logs test-container
          fi

          # Nettoyage
          echo "üßπ Nettoyage du conteneur de test..."
          docker stop test-container || true
          docker rm test-container || true
          echo "‚úÖ Test termin√© avec succ√®s!"

  # ==========================================
  # JOB 4: Create GitHub Release
  # ==========================================
  release:
    name: üöÄ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [tags, build]
    if: |
      github.event_name != 'pull_request' && 
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      needs.tags.outputs.tag_created == 'true'

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Verify Tag Exists
        run: |
          TAG_NAME="${{ needs.tags.outputs.tag_name }}"
          echo "üîç V√©rification que le tag $TAG_NAME existe sur le d√©p√¥t distant..."

          # R√©cup√©rer les tags du d√©p√¥t distant
          git fetch --tags

          # V√©rifier que le tag existe
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "‚úÖ Tag $TAG_NAME trouv√© localement"
          else
            echo "‚ö†Ô∏è Tag $TAG_NAME non trouv√© localement, tentative de r√©cup√©ration..."
            git fetch origin tag "$TAG_NAME" || {
              echo "‚ùå Erreur: Le tag $TAG_NAME n'existe pas sur le d√©p√¥t distant"
              echo "‚ÑπÔ∏è Le tag doit √™tre pouss√© avant de cr√©er la release"
              exit 1
            }
          fi

          # Afficher les informations du tag
          echo "üìã Informations du tag:"
          git show "$TAG_NAME" --no-patch --format="  SHA: %H%n  Auteur: %an%n  Date: %ad" || echo "  Impossible d'afficher les informations"

      - name: üìã Generate Release Notes
        id: release_notes
        run: |
          TAG_NAME="${{ needs.tags.outputs.tag_name }}"
          VERSION="${{ needs.tags.outputs.semantic_version }}"
          TAG_TYPE="${{ needs.tags.outputs.tag_type }}"
          IS_RELEASE="${{ needs.tags.outputs.is_release }}"

          # D√©terminer si c'est une release s√©mantique ou un tag de d√©veloppement
          if [ "$IS_RELEASE" = "true" ] && [ -n "$VERSION" ]; then
            RELEASE_TYPE="üéâ Release S√©mantique"
            IS_PRERELEASE="false"
            # R√©cup√©rer les commits depuis le dernier tag s√©mantique
            LAST_TAG=$(git describe --tags --abbrev=0 --match "v[0-9]*" 2>/dev/null || echo "")
            if [ -n "$LAST_TAG" ]; then
              echo "üìù G√©n√©ration des notes depuis le tag $LAST_TAG"
              COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
            else
              echo "üìù Premier tag s√©mantique, r√©cup√©ration des 10 derniers commits"
              COMMITS=$(git log -10 --pretty=format:"- %s (%h)" --no-merges)
            fi
          else
            RELEASE_TYPE="üîß Release de D√©veloppement"
            IS_PRERELEASE="true"
            # Pour les tags de d√©veloppement, r√©cup√©rer les 10 derniers commits
            echo "üìù Tag de d√©veloppement, r√©cup√©ration des 10 derniers commits"
            COMMITS=$(git log -10 --pretty=format:"- %s (%h)" --no-merges)
          fi

          # Cr√©er le body de la release en √©crivant directement dans le fichier
          {
            if [ "$IS_RELEASE" = "true" ] && [ -n "$VERSION" ]; then
              echo "## $RELEASE_TYPE"
              echo ""
              echo "**Version:** $VERSION"
              echo "**Tag:** $TAG_NAME"
              echo "**Type:** $TAG_TYPE"
              echo ""
              echo "### üì¶ Image Docker"
              echo "L'image Docker est disponible sur Docker Hub :"
              echo "\`\`\`"
              echo "docker pull ${{ env.DOCKER_IMAGE }}:$TAG_NAME"
              echo "docker pull ${{ env.DOCKER_IMAGE }}:latest"
              echo "\`\`\`"
            else
              echo "## $RELEASE_TYPE"
              echo ""
              echo "**Tag:** $TAG_NAME"
              echo "**Type:** $TAG_TYPE"
              echo ""
              echo "‚ö†Ô∏è **Note:** Ceci est une release de d√©veloppement. Pour une release de production, mettez √† jour la version dans \`package.json\`."
              echo ""
              echo "### üì¶ Image Docker"
              echo "L'image Docker est disponible sur Docker Hub :"
              echo "\`\`\`"
              echo "docker pull ${{ env.DOCKER_IMAGE }}:$TAG_NAME"
              echo "\`\`\`"
            fi
            echo ""
            echo "### üìù Changements"
            echo "$COMMITS"
            echo ""
            echo "### üîó Liens"
            echo "- **Docker Hub:** https://hub.docker.com/r/${{ env.DOCKER_IMAGE }}"
            echo "- **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})"
            echo ""
            echo "---"
            echo "*G√©n√©r√© automatiquement par GitHub Actions*"
          } > release_notes.md
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "‚úÖ Notes de release g√©n√©r√©es (Prerelease: $IS_PRERELEASE)"

          # Afficher un aper√ßu
          echo "üìÑ Aper√ßu des notes de release:"
          head -20 release_notes.md

      - name: üöÄ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.tags.outputs.tag_name }}
          name: Release ${{ needs.tags.outputs.tag_name }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ steps.release_notes.outputs.is_prerelease }}
          token: ${{ secrets.GITHUB_TOKEN }}
          generate_release_notes: false

  # ==========================================
  # JOB 5: Deploy to VPS
  # ==========================================
  deploy:
    name: üöÄ Deploy to VPS
    runs-on: ubuntu-latest
    needs: [build, test]
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîë Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: üîç Test SSH Connection
        run: |
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.VPS_PORT || 22 }} ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }} "echo '‚úÖ Connexion SSH r√©ussie'"

      - name: üê≥ Check & Setup Docker on Server
        run: |
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.VPS_PORT || 22 }} \
            ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }} << 'DOCKER_SETUP'
          set -e

          echo "üîç V√©rification de Docker..."

          # D√©tecter la distribution (n√©cessaire pour les installations)
          if [ -f /etc/os-release ]; then
            . /etc/os-release
            OS=$ID
          else
            OS="unknown"
          fi

          # V√©rifier si Docker est install√©
          if ! command -v docker &> /dev/null; then
            echo "‚ö†Ô∏è Docker n'est pas install√©, installation en cours..."
            
            if [ "$OS" = "unknown" ]; then
              echo "‚ùå Impossible de d√©tecter la distribution"
              exit 1
            fi
            
            # Installation selon la distribution
            if [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then
              echo "üì¶ Installation Docker pour Ubuntu/Debian..."
              sudo apt-get update -qq
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              sudo mkdir -p /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/$OS/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$OS $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -qq
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            elif [ "$OS" = "centos" ] || [ "$OS" = "rhel" ] || [ "$OS" = "fedora" ]; then
              echo "üì¶ Installation Docker pour CentOS/RHEL/Fedora..."
              sudo yum install -y yum-utils
              sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
              sudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            else
              echo "‚ùå Distribution non support√©e: $OS"
              exit 1
            fi
          else
            echo "‚úÖ Docker est d√©j√† install√©"
            docker --version
          fi

          # V√©rifier si Docker Compose est install√©
          if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
            echo "‚ö†Ô∏è Docker Compose n'est pas install√©, installation en cours..."
            if [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then
              sudo apt-get install -y docker-compose-plugin
            elif [ "$OS" = "centos" ] || [ "$OS" = "rhel" ] || [ "$OS" = "fedora" ]; then
              sudo yum install -y docker-compose-plugin
            fi
          else
            echo "‚úÖ Docker Compose est d√©j√† install√©"
            docker-compose --version 2>/dev/null || docker compose version
          fi

          # V√©rifier si le service Docker est d√©marr√©
          if ! sudo systemctl is-active --quiet docker 2>/dev/null; then
            echo "‚ö†Ô∏è Le service Docker n'est pas d√©marr√©, d√©marrage en cours..."
            sudo systemctl start docker
            sudo systemctl enable docker
          else
            echo "‚úÖ Le service Docker est d√©marr√©"
          fi

          # V√©rifier que l'utilisateur peut utiliser Docker (sans sudo)
          if ! docker ps &> /dev/null; then
            echo "‚ö†Ô∏è L'utilisateur ne peut pas utiliser Docker sans sudo, ajout au groupe docker..."
            CURRENT_USER=$(whoami)
            sudo usermod -aG docker "$CURRENT_USER"
            echo "‚úÖ Utilisateur $CURRENT_USER ajout√© au groupe docker"
            echo "‚ö†Ô∏è Note: Un red√©marrage de session SSH peut √™tre n√©cessaire pour que les changements prennent effet"
            echo "‚ö†Ô∏è Pour l'instant, nous utiliserons sudo docker si n√©cessaire"
          else
            echo "‚úÖ L'utilisateur peut utiliser Docker"
          fi

          # V√©rifier/cr√©er le r√©seau Docker kobecorp-network
          echo "üåê V√©rification du r√©seau Docker kobecorp-network..."
          if ! docker network ls | grep -q "kobecorp-network"; then
            echo "üì¶ Cr√©ation du r√©seau kobecorp-network..."
            docker network create kobecorp-network || sudo docker network create kobecorp-network
            echo "‚úÖ R√©seau kobecorp-network cr√©√©"
          else
            echo "‚úÖ R√©seau kobecorp-network existe d√©j√†"
          fi

          # Test final
          echo "üß™ Test final de Docker..."
          if docker ps &> /dev/null; then
            docker ps
            echo "‚úÖ Docker est pr√™t et fonctionne sans sudo!"
          elif sudo docker ps &> /dev/null; then
            sudo docker ps
            echo "‚úÖ Docker est pr√™t (utilise sudo pour l'instant)"
          else
            echo "‚ùå Erreur: Docker ne fonctionne pas"
            exit 1
          fi
          DOCKER_SETUP

      - name: üì¶ Prepare deployment files
        run: |
          # Cr√©er un dossier temporaire pour les fichiers de d√©ploiement
          mkdir -p .deploy

          # Copier les fichiers n√©cessaires pour le build Docker
          # Le docker-compose.yml utilise context: . donc tous les fichiers doivent √™tre dans setup-front/
          cp -r setup-front .deploy/
          cp package.json .deploy/
          cp package-lock.json .deploy/ 2>/dev/null || echo "package-lock.json non trouv√©, ignor√©"
          cp index.html .deploy/ 2>/dev/null || echo "index.html non trouv√©"
          cp vite.config.ts .deploy/ 2>/dev/null || echo "vite.config.ts non trouv√©"
          cp tsconfig.json .deploy/ 2>/dev/null || echo "tsconfig.json non trouv√©"
          cp tsconfig.app.json .deploy/ 2>/dev/null || echo "tsconfig.app.json non trouv√©"
          cp tsconfig.node.json .deploy/ 2>/dev/null || echo "tsconfig.node.json non trouv√©"
          cp tailwind.config.js .deploy/ 2>/dev/null || echo "tailwind.config.js non trouv√©"
          cp postcss.config.js .deploy/ 2>/dev/null || echo "postcss.config.js non trouv√©"
          cp eslint.config.js .deploy/ 2>/dev/null || echo "eslint.config.js non trouv√©"

          # Copier les dossiers essentiels
          cp -r src .deploy/ 2>/dev/null || echo "src/ non trouv√©"
          cp -r public .deploy/ 2>/dev/null || echo "public/ non trouv√©"

          # Copier le fichier .env depuis setup-front/ (important pour le d√©ploiement)
          if [ -f "setup-front/.env" ]; then
            cp setup-front/.env .deploy/setup-front/.env
            echo "‚úÖ Fichier .env copi√© dans .deploy/setup-front/"
          else
            echo "‚ö†Ô∏è Fichier setup-front/.env non trouv√©"
          fi

          # V√©rifier que nginx.conf est bien dans setup-front/
          if [ ! -f ".deploy/setup-front/nginx.conf" ]; then
            echo "‚ùå Erreur: nginx.conf n'est pas dans .deploy/setup-front/"
            echo "üìã Contenu de .deploy/setup-front/:"
            ls -la .deploy/setup-front/ || echo "R√©pertoire non trouv√©"
            echo "üìã Recherche de nginx.conf:"
            find .deploy -name "nginx.conf" 2>/dev/null || echo "nginx.conf non trouv√©"
            exit 1
          fi

          # V√©rifier que Dockerfile est bien dans setup-front/
          if [ ! -f ".deploy/setup-front/Dockerfile" ]; then
            echo "‚ùå Erreur: Dockerfile n'est pas dans .deploy/setup-front/"
            echo "üìã Contenu de .deploy/setup-front/:"
            ls -la .deploy/setup-front/ || echo "R√©pertoire non trouv√©"
            exit 1
          fi

          echo "‚úÖ Fichiers de d√©ploiement pr√©par√©s"
          echo "‚úÖ nginx.conf v√©rifi√© dans .deploy/setup-front/"
          echo "‚úÖ Dockerfile v√©rifi√© dans .deploy/setup-front/"

      - name: üîß Configure SSH
        run: |
          # Cr√©er le fichier de config SSH
          mkdir -p ~/.ssh
          cat >> ~/.ssh/config << EOF
          Host vps-deploy
            HostName ${{ secrets.VPS_HOST }}
            User ${{ secrets.VPS_USERNAME }}
            Port ${{ secrets.VPS_PORT || 22 }}
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF

          # Ajouter le serveur aux known hosts
          ssh-keyscan -p ${{ secrets.VPS_PORT || 22 }} -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: üßπ Clean old deployment files
        run: |
          # Recr√©er le fichier de config SSH pour cette √©tape
          mkdir -p ~/.ssh
          cat > ~/.ssh/config << EOF
          Host vps-deploy
            HostName ${{ secrets.VPS_HOST }}
            User ${{ secrets.VPS_USERNAME }}
            Port ${{ secrets.VPS_PORT || 22 }}
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config

          ssh -F ~/.ssh/config vps-deploy << 'EOF'
            set -e
            
            echo "üßπ Nettoyage des anciens fichiers de d√©ploiement..."
            
            # Arr√™ter et supprimer les anciens conteneurs ben-djibril
            if docker ps -a --format '{{.Names}}' | grep -q "ben-djibril-site"; then
              echo "üõë Arr√™t des anciens conteneurs ben-djibril..."
              docker stop ben-djibril-site 2>/dev/null || sudo docker stop ben-djibril-site 2>/dev/null || true
              docker rm ben-djibril-site 2>/dev/null || sudo docker rm ben-djibril-site 2>/dev/null || true
            fi
            
            # Supprimer les anciens dossiers de d√©ploiement
            if [ -d "/opt/ben-djibril" ]; then
              echo "üóëÔ∏è Suppression de l'ancien r√©pertoire /opt/ben-djibril..."
              sudo rm -rf /opt/ben-djibril || true
            fi
            
            # Cr√©er la structure de dossiers pour ben-djibril dans kobe-corporation
            echo "üìÅ Cr√©ation de la structure de dossiers..."
            mkdir -p ~/kobe-corporation/ben-djibril/setup-front
            
            echo "‚úÖ Nettoyage termin√©"
          EOF

      - name: üì§ Copy files to VPS
        run: |
          echo "üì§ Copie des fichiers vers le serveur..."

          # Cr√©er le r√©pertoire .ssh s'il n'existe pas
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Ajouter le serveur aux known hosts
          ssh-keyscan -p ${{ secrets.VPS_PORT || 22 }} -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 600 ~/.ssh/known_hosts 2>/dev/null || true

          # Copier setup-front/ vers le serveur
          # IMPORTANT: Utiliser --include pour s'assurer que nginx.conf et .env sont copi√©s
          rsync -avz --delete \
            --include="nginx.conf" \
            --include=".env" \
            -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.VPS_PORT || 22 }}" \
            .deploy/setup-front/ \
            ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }}:~/kobe-corporation/ben-djibril/setup-front/

          # Copier les fichiers n√©cessaires pour le build Docker √† la racine de ~/kobe-corporation/ben-djibril/
          # Le docker-compose.yml utilise context: .. donc le contexte est ~/kobe-corporation/ben-djibril/ (parent de setup-front/)
          echo "üì¶ Copie des fichiers de build √† la racine..."

          # Copier package.json (obligatoire)
          if [ -f ".deploy/package.json" ]; then
            rsync -avz \
              -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.VPS_PORT || 22 }}" \
              .deploy/package.json \
              ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }}:~/kobe-corporation/ben-djibril/
          else
            echo "‚ùå Erreur: package.json n'existe pas dans .deploy/"
            exit 1
          fi

          # Copier package-lock.json si disponible
          if [ -f ".deploy/package-lock.json" ]; then
            rsync -avz \
              -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.VPS_PORT || 22 }}" \
              .deploy/package-lock.json \
              ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }}:~/kobe-corporation/ben-djibril/
          fi

          # Copier les fichiers de configuration n√©cessaires
          for file in index.html vite.config.ts tsconfig.json tsconfig.app.json tsconfig.node.json tailwind.config.js postcss.config.js eslint.config.js; do
            if [ -f ".deploy/$file" ]; then
              rsync -avz \
                -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.VPS_PORT || 22 }}" \
                .deploy/$file \
                ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }}:~/kobe-corporation/ben-djibril/
            fi
          done

          # Copier les dossiers src/ et public/ (obligatoires)
          if [ -d ".deploy/src" ]; then
            rsync -avz \
              -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.VPS_PORT || 22 }}" \
              .deploy/src/ \
              ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }}:~/kobe-corporation/ben-djibril/src/
          else
            echo "‚ùå Erreur: src/ n'existe pas dans .deploy/"
            exit 1
          fi

          if [ -d ".deploy/public" ]; then
            rsync -avz \
              -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p ${{ secrets.VPS_PORT || 22 }}" \
              .deploy/public/ \
              ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }}:~/kobe-corporation/ben-djibril/public/
          else
            echo "‚ùå Erreur: public/ n'existe pas dans .deploy/"
            exit 1
          fi

          echo "‚úÖ Tous les fichiers ont √©t√© copi√©s vers le serveur"

          # V√©rifier que les fichiers sont bien copi√©s sur le serveur
          echo "üîç V√©rification des fichiers copi√©s sur le serveur..."
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.VPS_PORT || 22 }} \
            ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }} << 'VERIFY_FILES'
          set -e

          DEPLOY_PATH="$HOME/kobe-corporation/ben-djibril"

          echo "üìã V√©rification de $DEPLOY_PATH/package.json:"
          if [ -f "$DEPLOY_PATH/package.json" ]; then
            echo "‚úÖ package.json trouv√©"
            ls -lh "$DEPLOY_PATH/package.json"
          else
            echo "‚ùå ERREUR: package.json n'est pas pr√©sent dans $DEPLOY_PATH"
            echo "üìã Contenu de $DEPLOY_PATH:"
            ls -la "$DEPLOY_PATH" | head -20
            exit 1
          fi

          echo "üìã V√©rification de $DEPLOY_PATH/src:"
          if [ -d "$DEPLOY_PATH/src" ]; then
            echo "‚úÖ src/ trouv√©"
            ls -ld "$DEPLOY_PATH/src"
          else
            echo "‚ùå ERREUR: src/ n'est pas pr√©sent dans $DEPLOY_PATH"
            exit 1
          fi

          echo "üìã V√©rification de $DEPLOY_PATH/public:"
          if [ -d "$DEPLOY_PATH/public" ]; then
            echo "‚úÖ public/ trouv√©"
            ls -ld "$DEPLOY_PATH/public"
          else
            echo "‚ùå ERREUR: public/ n'est pas pr√©sent dans $DEPLOY_PATH"
            exit 1
          fi

          echo "‚úÖ Tous les fichiers n√©cessaires sont pr√©sents sur le serveur"
          VERIFY_FILES

      - name: üê≥ Deploy Docker Containers
        run: |
          # Recr√©er le fichier de config SSH pour cette √©tape
          mkdir -p ~/.ssh
          cat > ~/.ssh/config << EOF
          Host vps-deploy
            HostName ${{ secrets.VPS_HOST }}
            User ${{ secrets.VPS_USERNAME }}
            Port ${{ secrets.VPS_PORT || 22 }}
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config

          ssh -F ~/.ssh/config vps-deploy << 'DEPLOY_DOCKER'
          set -e

          # Fonction pour d√©terminer la commande Docker √† utiliser
          get_docker_cmd() {
            if docker ps &> /dev/null 2>&1; then
              echo "docker"
            else
              echo "sudo docker"
            fi
          }

          DOCKER_CMD=$(get_docker_cmd)

          # Fonction pour ex√©cuter docker-compose (utilise sudo si n√©cessaire)
          get_compose_cmd() {
            if docker ps &> /dev/null 2>&1; then
              if command -v docker-compose &> /dev/null; then
                echo "docker-compose"
              else
                echo "docker compose"
              fi
            else
              if command -v docker-compose &> /dev/null; then
                echo "sudo docker-compose"
              else
                echo "sudo docker compose"
              fi
            fi
          }

          COMPOSE_CMD=$(get_compose_cmd)

          DEPLOY_PATH="$HOME/kobe-corporation/ben-djibril"
          DOCKER_COMPOSE_PATH="$DEPLOY_PATH/setup-front"

          # V√©rifier que les fichiers n√©cessaires sont pr√©sents dans le contexte Docker (DEPLOY_PATH)
          echo "üîç V√©rification des fichiers n√©cessaires pour le build Docker..."
          echo "üìÅ Contexte Docker: $DEPLOY_PATH"
          echo "üìã Contenu de $DEPLOY_PATH:"
          ls -la "$DEPLOY_PATH" | head -20 || echo "‚ö†Ô∏è R√©pertoire non trouv√© ou vide"

          # V√©rifier package.json (obligatoire)
          if [ ! -f "$DEPLOY_PATH/package.json" ]; then
            echo "‚ùå ERREUR: package.json n'est pas pr√©sent dans $DEPLOY_PATH"
            echo "üìã Recherche de package.json:"
            find "$DEPLOY_PATH" -name "package.json" 2>/dev/null || echo "‚ùå package.json non trouv√©"
            exit 1
          else
            echo "‚úÖ package.json trouv√© dans $DEPLOY_PATH"
          fi

          # V√©rifier src/ (obligatoire)
          if [ ! -d "$DEPLOY_PATH/src" ]; then
            echo "‚ùå ERREUR: src/ n'est pas pr√©sent dans $DEPLOY_PATH"
            exit 1
          else
            echo "‚úÖ src/ trouv√© dans $DEPLOY_PATH"
          fi

          # V√©rifier public/ (obligatoire)
          if [ ! -d "$DEPLOY_PATH/public" ]; then
            echo "‚ùå ERREUR: public/ n'est pas pr√©sent dans $DEPLOY_PATH"
            exit 1
          else
            echo "‚úÖ public/ trouv√© dans $DEPLOY_PATH"
          fi

          cd "$DOCKER_COMPOSE_PATH"

          # V√©rifier que nginx.conf existe
          if [ ! -f "nginx.conf" ]; then
            echo "‚ùå Erreur: nginx.conf n'est pas pr√©sent dans $DOCKER_COMPOSE_PATH"
            exit 1
          fi

          # V√©rifier que compose.yaml existe
          if [ ! -f "compose.yaml" ]; then
            echo "‚ùå Erreur: compose.yaml n'est pas pr√©sent dans $DOCKER_COMPOSE_PATH"
            exit 1
          fi

          # V√©rifier le .dockerignore dans le contexte Docker (DEPLOY_PATH) et s'assurer qu'il n'exclut pas package.json
          echo "üìã V√©rification du .dockerignore dans le contexte Docker ($DEPLOY_PATH):"
          if [ -f "$DEPLOY_PATH/.dockerignore" ]; then
            echo "‚úÖ .dockerignore trouv√© dans $DEPLOY_PATH"
            echo "üìÑ Contenu du .dockerignore:"
            cat "$DEPLOY_PATH/.dockerignore" | head -30
            if grep -E "^package\.json$|^package-lock\.json$" "$DEPLOY_PATH/.dockerignore" 2>/dev/null; then
              echo "‚ùå ERREUR: package.json est exclu par .dockerignore!"
              echo "üîß Correction du .dockerignore..."
              # Retirer package.json du .dockerignore s'il y est
              grep -v -E "^package\.json$|^package-lock\.json$" "$DEPLOY_PATH/.dockerignore" > "$DEPLOY_PATH/.dockerignore.tmp" && mv "$DEPLOY_PATH/.dockerignore.tmp" "$DEPLOY_PATH/.dockerignore"
              echo "‚úÖ .dockerignore corrig√©"
            else
              echo "‚úÖ package.json n'est PAS exclu par .dockerignore"
            fi
          else
            echo "‚ö†Ô∏è .dockerignore non trouv√© dans $DEPLOY_PATH (ce n'est pas grave, Docker n'utilisera pas de .dockerignore)"
          fi

          # V√©rifier le .dockerignore dans setup-front/ et s'assurer qu'il n'exclut pas nginx.conf
          echo "üìã V√©rification du .dockerignore dans setup-front/:"
          if [ -f ".dockerignore" ]; then
            echo "‚úÖ .dockerignore trouv√© dans setup-front/"
            echo "üìÑ Contenu du .dockerignore:"
            cat .dockerignore | head -20
            if grep -E "^nginx\.conf$|^setup-front/nginx\.conf$" .dockerignore 2>/dev/null; then
              echo "‚ùå ERREUR: nginx.conf est exclu par .dockerignore!"
              echo "üîß Correction du .dockerignore..."
              # Retirer nginx.conf du .dockerignore s'il y est
              grep -v -E "^nginx\.conf$|^setup-front/nginx\.conf$" .dockerignore > .dockerignore.tmp && mv .dockerignore.tmp .dockerignore
              echo "‚úÖ .dockerignore corrig√©"
            else
              echo "‚úÖ nginx.conf n'est PAS exclu par .dockerignore"
            fi
          else
            echo "‚ö†Ô∏è .dockerignore non trouv√© dans setup-front/ (ce n'est pas grave)"
          fi

          # V√©rifier que le fichier .env existe dans setup-front/
          echo "üìã V√©rification du fichier .env dans setup-front/:"
          if [ ! -f ".env" ]; then
            echo "‚ö†Ô∏è Fichier .env non trouv√© dans setup-front/, cr√©ation d'un fichier .env par d√©faut..."
            cat > .env << 'ENV_FILE'
          APP_DOMAIN=ben-djibril.kobecorporation.com
          APP_URL=https://ben-djibril.kobecorporation.com
          VITE_EMAILJS_PUBLIC_KEY=your_public_key_here
          VITE_EMAILJS_SERVICE_ID=your_service_id_here
          VITE_EMAILJS_CONTACT_TEMPLATE_ID=your_contact_template_id_here
          VITE_EMAILJS_NEWSLETTER_TEMPLATE_ID=your_newsletter_template_id_here
          ENV_FILE
            echo "‚ö†Ô∏è IMPORTANT: Vous devez configurer les variables EmailJS dans setup-front/.env sur le serveur!"
          else
            echo "‚úÖ Fichier .env trouv√© dans setup-front/"
            echo "üìã V√©rification du domaine dans .env:"
            if grep -q "ben-djibril.kobecorporation.com" .env; then
              echo "‚úÖ Domaine ben-djibril.kobecorporation.com trouv√© dans .env"
            else
              echo "‚ö†Ô∏è Domaine ben-djibril.kobecorporation.com non trouv√© dans .env"
            fi
          fi

          # Build et d√©marrer les conteneurs
          echo ""
          echo "üî® Build et d√©marrage des conteneurs..."
          # Utiliser -f pour sp√©cifier explicitement le fichier compose.yaml
          if echo "$COMPOSE_CMD" | grep -q "docker compose"; then
            # Pour docker compose (v2)
            $COMPOSE_CMD -f compose.yaml pull || echo "‚ö†Ô∏è Pull √©chou√©, utilisation de l'image locale"
            $COMPOSE_CMD -f compose.yaml up -d --build --force-recreate
          else
            # Pour docker-compose (v1)
            $COMPOSE_CMD -f compose.yaml pull || echo "‚ö†Ô∏è Pull √©chou√©, utilisation de l'image locale"
            $COMPOSE_CMD -f compose.yaml up -d --build --force-recreate
          fi

          # Attendre que les conteneurs soient pr√™ts
          echo "‚è≥ Attente du d√©marrage des conteneurs..."
          sleep 10

          # V√©rifier le statut des conteneurs
          echo "üìä Statut des conteneurs:"
          if echo "$COMPOSE_CMD" | grep -q "docker compose"; then
            $COMPOSE_CMD -f compose.yaml ps
          else
            $COMPOSE_CMD -f compose.yaml ps
          fi

          # V√©rifier que le conteneur est bien d√©marr√©
          if echo "$COMPOSE_CMD" | grep -q "docker compose"; then
            if $COMPOSE_CMD -f compose.yaml ps | grep -q "Up"; then
              echo "‚úÖ Conteneurs d√©marr√©s avec succ√®s!"
            else
              echo "‚ùå Erreur: Les conteneurs ne sont pas d√©marr√©s"
              $COMPOSE_CMD -f compose.yaml logs
              exit 1
            fi
          else
            if $COMPOSE_CMD -f compose.yaml ps | grep -q "Up"; then
              echo "‚úÖ Conteneurs d√©marr√©s avec succ√®s!"
            else
              echo "‚ùå Erreur: Les conteneurs ne sont pas d√©marr√©s"
              $COMPOSE_CMD -f compose.yaml logs
              exit 1
            fi
          fi

          # Afficher les logs r√©cents
          echo "üìã Logs r√©cents:"
          if echo "$COMPOSE_CMD" | grep -q "docker compose"; then
            $COMPOSE_CMD -f compose.yaml logs --tail=50
          else
            $COMPOSE_CMD -f compose.yaml logs --tail=50
          fi
          DEPLOY_DOCKER

      - name: ‚úÖ Verify deployment
        run: |
          echo "‚úÖ V√©rification du d√©ploiement..."

          # Recr√©er le fichier de config SSH pour cette √©tape
          mkdir -p ~/.ssh
          cat > ~/.ssh/config << EOF
          Host vps-deploy
            HostName ${{ secrets.VPS_HOST }}
            User ${{ secrets.VPS_USERNAME }}
            Port ${{ secrets.VPS_PORT || 22 }}
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config

          ssh -F ~/.ssh/config vps-deploy << 'VERIFY'
          set -e

          # Fonction pour d√©terminer la commande Docker √† utiliser
          get_docker_cmd() {
            if docker ps &> /dev/null 2>&1; then
              echo "docker"
            else
              echo "sudo docker"
            fi
          }

          DOCKER_CMD=$(get_docker_cmd)

          # Fonction pour ex√©cuter docker-compose (utilise sudo si n√©cessaire)
          get_compose_cmd() {
            if docker ps &> /dev/null 2>&1; then
              if command -v docker-compose &> /dev/null; then
                echo "docker-compose"
              else
                echo "docker compose"
              fi
            else
              if command -v docker-compose &> /dev/null; then
                echo "sudo docker-compose"
              else
                echo "sudo docker compose"
              fi
            fi
          }

          COMPOSE_CMD=$(get_compose_cmd)

          DEPLOY_PATH="$HOME/kobe-corporation/ben-djibril"
          DOCKER_COMPOSE_PATH="$DEPLOY_PATH/setup-front"

          cd "$DOCKER_COMPOSE_PATH"

          # V√©rifier que le conteneur est en cours d'ex√©cution
          if $COMPOSE_CMD -f compose.yaml ps | grep -q "Up"; then
            echo "‚úÖ D√©ploiement r√©ussi! Le conteneur est en cours d'ex√©cution."
            
            # Afficher les informations du conteneur
            echo ""
            echo "üìä Informations du conteneur:"
            $DOCKER_CMD ps --filter "name=ben-djibril-site" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # V√©rifier que le conteneur est sur le bon r√©seau
            echo ""
            echo "üåê V√©rification du r√©seau Docker..."
            if $DOCKER_CMD inspect ben-djibril-site --format '{{range $key, $value := .NetworkSettings.Networks}}{{$key}}{{end}}' 2>/dev/null | grep -q "kobecorp-network"; then
              echo "‚úÖ Le conteneur est sur le r√©seau kobecorp-network"
            else
              echo "‚ö†Ô∏è Le conteneur n'est pas sur le r√©seau kobecorp-network"
              echo "üìã R√©seaux du conteneur:"
              $DOCKER_CMD inspect ben-djibril-site --format '{{range $key, $value := .NetworkSettings.Networks}}{{$key}} {{end}}' 2>/dev/null || echo "Aucun r√©seau trouv√©"
            fi
            
            # Test de sant√© (optionnel)
            CONTAINER_IP=$($DOCKER_CMD inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ben-djibril-site 2>/dev/null || echo "")
            if [ -n "$CONTAINER_IP" ]; then
              echo ""
              echo "üåê IP du conteneur: $CONTAINER_IP"
              echo "üîç Test de connectivit√©..."
              curl -f http://localhost:80 > /dev/null 2>&1 && echo "‚úÖ L'application r√©pond sur le port 80" || echo "‚ö†Ô∏è L'application ne r√©pond pas encore (peut √™tre normal si elle d√©marre)"
            fi
          else
            echo "‚ùå Erreur: Le conteneur n'est pas en cours d'ex√©cution"
            $COMPOSE_CMD -f compose.yaml ps
            $COMPOSE_CMD -f compose.yaml logs --tail=100
            exit 1
          fi
          VERIFY

      - name: üéâ Deployment Summary
        if: success()
        run: |
          echo ""
          echo "üéâ =========================================="
          echo "üéâ D√âPLOIEMENT R√âUSSI!"
          echo "üéâ =========================================="
          echo ""
          echo "üì¶ Image Docker: ${{ env.DOCKER_IMAGE }}:latest"
          echo "üåê Serveur: ${{ secrets.VPS_HOST }}"
          echo "üìÅ Chemin de d√©ploiement: ~/kobe-corporation/ben-djibril/setup-front"
          echo "üê≥ Conteneur: ben-djibril-site"
          echo "üåê R√©seau Docker: kobecorp-network"
          echo "üîå Port interne: 80"
          echo ""
          echo "‚úÖ L'application est maintenant d√©ploy√©e et accessible!"
          echo "üìù Note: Le proxy Nginx doit √™tre configur√© pour utiliser ben-djibril-site:80"
          echo ""
